以下にQ2.2.2の回答を入力

- ルール ----------------------------------------------
  1. フィールドの値がnullであることを許可する
  2. インスタンス化した後のフィールドの値の変更は禁⽌する
  3. 今後の仕様変更でフィールドの値の個数が増えることを許容する
  4. 他クラスからのコンストラクタの呼び出しを禁⽌する
------------------------------------------------------

まず、あるクラスのインスタンス化をフィールドの値をセットして行う際、
通常は引数付きコンストラクタを用いるが、
ビルダパターンを採用すると、
それぞれのフィールド名で生成された引数付きメソッドを.(ドット)で繋げて使用する。(メソッドチェーン)

このとき、すべてのメソッドを用いる必要はなく、
使用しなかったメソッド名のフィールド値はnullとなり、許容される。
したがって、通常では、コンストラクタの引数に値の不足があるとエラーとなるが、
ビルダパターンでは、メソッドの不足が許容されるため、エラーの防止やコード量の削減が期待できる。(ルール1)

また、ビルダパターンではメソッドチェーンのはじめと終わりに
特定の処理をすることでインスタンスを生成しているため、
インスタンス化した後にメソッドを呼び出し、フィールドの値を変更することはできない。
したがって、通常では、Setterで変更することができるが、
ビルダパターンでは、使用可能なSetterが用意されず、使用することができないので、
フィールド値の変更の禁止が約束できる。(ルール2)

もし、今後の仕様変更でフィールドの値の個数が増える場合、
通常では、そのクラスと呼び出すクラスのコンストラクタの修正が必要となる。
今回、システム内の多くのクラスでインスタンス化されることが想定されるという条件があるため、
エラーを防止するために膨大な量の修正が求められてしまう。
ビルダパターンでは、そのクラスのコードは自動生成されるため変更箇所が少なく済む。
また、インスタンス化の際でも
値をセットしないことが許容されるため、致命的なエラーは発生しにくいと考えられる。(ルール3)

他クラスからのコンストラクタの呼び出しを禁止する場合、
通常では、コンストラクタのアクセス修飾子をprivateにするなどして対応できるが、
インスタンス化をするときフィールドに任意の値をセットすることができない。
ビルダパターンでは、インスタンス化にコンストラクタを必要としないため、
コンストラクタの呼び出しの禁止を約束できる(ルール4)
